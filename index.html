<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sunburst Chart – EMSI Data (Generation → Occupation)</title>
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <!-- (Optional) Load the Tableau Extensions API -->
  <script src="https://tableau.github.io/extensions-api/tableau.extensions.1.latest.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .chart-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .arc {
      cursor: pointer;
      stroke: #fff;
      stroke-width: 1px;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 6px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
    }
    /* White text for labels */
    .arc-label {
      fill: white;
      font-size: 12px;
      text-anchor: middle;
      pointer-events: none; /* so text doesn't block mouse events on arcs */
    }
  </style>
</head>
<body>
  <h2>Sunburst Chart: Generation (Inner Ring) → Occupation (Outer Ring)</h2>
  <p>This visualization groups jobs by Generation and Occupation using the 2013 Jobs column. Now with labels!</p>
  <div class="chart-container">
    <svg id="sunburst" width="700" height="700"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>

  <script>
    // -------------------------------------------------------------------
    // 1) Sunburst Layout Setup
    // -------------------------------------------------------------------
    const width = 700,
          height = 700,
          radius = Math.min(width, height) / 2;

    const svg = d3.select("#sunburst")
                  .attr("viewBox", [-width / 2, -height / 2, width, height]);

    const tooltip = d3.select("#tooltip");

    // Create a partition layout
    const partition = d3.partition()
      .size([2 * Math.PI, radius]);

    // Create an arc generator
    const arc = d3.arc()
      .startAngle(d => d.x0)
      .endAngle(d => d.x1)
      .innerRadius(d => d.y0)
      .outerRadius(d => d.y1);

    // Color scale (you can customize as needed)
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    // -------------------------------------------------------------------
    // 2) Build Hierarchy from CSV Data
    // -------------------------------------------------------------------
    function buildHierarchy(csvData) {
      // We'll group by Generation -> Occupation, summing "2013 Jobs".
      const nestedMap = d3.rollup(
        csvData,
        v => d3.sum(v, d => d.jobs2013),
        d => d.generation,    // first grouping: Generation
        d => d.occupation     // second grouping: Occupation
      );

      // Convert nestedMap into a hierarchical object
      const root = { name: "All Jobs", children: [] };

      for (const [genKey, occMap] of nestedMap.entries()) {
        const genNode = { name: genKey, children: [] };
        for (const [occKey, totalJobs] of occMap.entries()) {
          genNode.children.push({
            name: occKey,
            value: totalJobs
          });
        }
        root.children.push(genNode);
      }
      return root;
    }

    // -------------------------------------------------------------------
    // 3) Draw the Sunburst (with labels)
    // -------------------------------------------------------------------
    function drawSunburst(data) {
      // Convert data to a d3 hierarchy, sum the values, and partition it
      const root = d3.hierarchy(data)
                     .sum(d => d.value);

      partition(root); // mutates root, adding x0, x1, y0, y1

      // Group arcs + labels together
      const arcsGroup = svg.selectAll("g.arc-group")
        .data(root.descendants())
        .join("g")
        .attr("class", "arc-group");

      // Draw arcs
      arcsGroup.append("path")
        .attr("class", "arc")
        .attr("fill", d => {
          // Depth 0=All Jobs, 1=Generation, 2=Occupation
          if (d.depth === 1) return color(d.data.name);     // Generation
          if (d.depth === 2) return color(d.parent.data.name); // Occupation uses parent's color
          return "#ccc"; // Root node color
        })
        .attr("d", arc)
        .on("mouseover", function(event, d) {
          // Show tooltip
          tooltip.style("opacity", 1);
          const generation = (d.depth === 2) ? d.parent.data.name : d.data.name;
          const occupation = (d.depth === 2) ? d.data.name : "";
          const jobs = d.value ? d.value.toLocaleString() : "";
          tooltip.html(`
            <strong>${generation}</strong><br/>
            ${occupation ? occupation + "<br/>" : ""}
            Jobs: ${jobs}
          `)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY + 10) + "px");
        })
        .on("mousemove", function(event) {
          // Move tooltip
          tooltip.style("left", (event.pageX + 10) + "px")
                 .style("top", (event.pageY + 10) + "px");
        })
        .on("mouseout", function() {
          // Hide tooltip
          tooltip.style("opacity", 0);
        })
        .on("click", function(event, d) {
          // (Optional) Apply a Tableau filter if integrating with the Extensions API
          if (tableauEnv.isTableau) {
            applyTableauFilter(d);
          }
        });

      // --- Add labels in white text ---
      arcsGroup.append("text")
        .attr("class", "arc-label")
        .attr("transform", d => labelTransform(d))
        .attr("dy", "0.35em")
        .text(d => {
          // Skip labeling the root or extremely small arcs
          if (d.depth === 0) return "";
          // If the arc angle is too small, skip the label to avoid clutter
          const angle = d.x1 - d.x0;
          if (angle < 0.01) return "";
          return d.data.name;
        });
    }

    // Helper function for label positioning
    function labelTransform(d) {
      // Center angle in radians
      const angle = (d.x0 + d.x1) / 2;
      // Convert to degrees and rotate so "midpoint" is at -90
      const rotate = (angle * 180 / Math.PI) - 90;
      // Radius is halfway between inner and outer
      const r = (d.y0 + d.y1) / 2;
      // If rotate >= 180, flip the text to avoid upside-down labels
      const flip = rotate < 180 ? 0 : 180;
      return `rotate(${rotate}) translate(${r},0) rotate(${flip})`;
    }

    // -------------------------------------------------------------------
    // 4) Load CSV and Render
    // -------------------------------------------------------------------
    function loadDataAndRender() {
      // Replace the URL with your own GitHub Pages CSV path if needed:
      d3.csv("https://amandarae220.github.io/emsi-sunburst/data.csv").then(rawData => {
        // Parse CSV columns
        const parsed = rawData.map(d => {
          return {
            generation: d["Generation"] || "Unknown",
            occupation: d["Occupation"] || "Unknown",
            jobs2013: +String(d["2013 Jobs"]).replace(/,/g, "") // parse "2013 Jobs" as number
          };
        });

        // Build hierarchical structure
        const hierarchyData = buildHierarchy(parsed);

        // Draw the sunburst
        drawSunburst(hierarchyData);
      });
    }

    // -------------------------------------------------------------------
    // 5) (Optional) Tableau Extensions – Two‐Way Filtering
    // -------------------------------------------------------------------
    const tableauEnv = {
      isTableau: false,
      worksheet: null
    };

    function applyTableauFilter(d) {
      // Example logic: if user clicks a Generation-level arc, filter on "Generation".
      // If Occupation-level arc, filter on "Occupation".
      const depth = d.depth;
      let filterField = null;
      let filterValue = null;

      if (depth === 1) {
        filterField = "Generation";
        filterValue = d.data.name;
      } else if (depth === 2) {
        filterField = "Occupation";
        filterValue = d.data.name;
      } else {
        return; // skip root
      }

      if (tableauEnv.worksheet) {
        tableauEnv.worksheet.applyFilterAsync(
          filterField,
          filterValue,
          tableau.FilterUpdateType.Replace
        ).then(() => {
          console.log(`Applied filter: ${filterField} = ${filterValue}`);
        }).catch(err => console.error("Error applying filter:", err));
      }
    }

    function updateFromTableau(event) {
      // Re-load data or parse the event for more specific filtering
      console.log("Received Tableau filter event:", event);
      loadDataAndRender();
    }

    function setupTableauExtension() {
      if (typeof tableau === "undefined") {
        console.log("Not in a Tableau environment (test mode).");
        return;
      }
      tableau.extensions.initializeAsync().then(() => {
        tableauEnv.isTableau = true;
        const dashboard = tableau.extensions.dashboardContent.dashboard;
        // Example: Use the first worksheet
        tableauEnv.worksheet = dashboard.worksheets[0];

        // Listen for filter changes
        dashboard.worksheets.forEach(ws => {
          ws.addEventListener(tableau.TableauEventType.FilterChanged, updateFromTableau);
        });
      });
    }

    // -------------------------------------------------------------------
    // 6) Initialize
    // -------------------------------------------------------------------
    loadDataAndRender();
    setupTableauExtension();
  </script>
</body>
</html>
