<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sunburst Chart â€“ Radial (Perpendicular) Labels</title>
  <!-- Load d3.js v6 -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .arc {
      cursor: pointer;
      stroke: #fff;
      stroke-width: 1px;
    }
    .arc-label {
      fill: white;
      font-size: 12px;
      text-anchor: middle;
      pointer-events: none;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 6px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
    }
  </style>
</head>
<body>
  <svg id="sunburst" width="700" height="700"></svg>
  <div class="tooltip" id="tooltip"></div>
  <script>
    // Dimensions and radius
    const width = 700,
          height = 700,
          radius = Math.min(width, height) / 2;
          
    // Select SVG and tooltip container
    const svg = d3.select("#sunburst")
                  .attr("viewBox", [-width/2, -height/2, width, height]);
    const tooltip = d3.select("#tooltip");

    // Partition layout
    const partition = d3.partition()
                        .size([2 * Math.PI, radius]);

    // Arc generator
    const arc = d3.arc()
                  .startAngle(d => d.x0)
                  .endAngle(d => d.x1)
                  .innerRadius(d => d.y0)
                  .outerRadius(d => d.y1);

    // Color scale
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    // Define minimum width for displaying a label (in pixels)
    const minLabelWidth = 12;

    // Revised computeTextRotation: Use the mid-angle in degrees (without subtracting 90)
    // and flip by 180 if the angle is between 90 and 270 so that text appears upright.
    function computeTextRotation(d) {
      let angle = (d.x0 + d.x1) / 2 * 180 / Math.PI;
      if (angle > 90 && angle < 270) {
        angle += 180;
      }
      return angle;
    }

    // Standard text wrapping function using <tspan>
    function wrap(text, width) {
      text.each(function() {
        var textElem = d3.select(this),
            words = textElem.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // in ems
            y = textElem.attr("y") || 0,
            dy = parseFloat(textElem.attr("dy")) || 0,
            tspan = textElem.text(null)
                             .append("tspan")
                             .attr("x", 0)
                             .attr("y", y)
                             .attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = textElem.append("tspan")
                            .attr("x", 0)
                            .attr("y", y)
                            .attr("dy", ++lineNumber * lineHeight + dy + "em")
                            .text(word);
          }
        }
      });
    }

    // Build hierarchical data from CSV rows.
    // Assumes CSV has columns "Generation", "Occupation", "2013 Jobs"
    function buildHierarchy(csvData) {
      const nestedMap = d3.rollup(
        csvData,
        v => d3.sum(v, d => d.jobs2013),
        d => d.generation,
        d => d.occupation
      );
      const root = { name: "All Jobs", children: [] };
      for (const [gen, occMap] of nestedMap.entries()) {
        const genNode = { name: gen, children: [] };
        for (const [occ, total] of occMap.entries()) {
          genNode.children.push({ name: occ, value: total });
        }
        root.children.push(genNode);
      }
      return root;
    }

    // Draw the sunburst chart with labels.
    function drawSunburst(data) {
      const root = d3.hierarchy(data)
                     .sum(d => d.value);
      partition(root);

      const groups = svg.selectAll("g.arc-group")
                        .data(root.descendants())
                        .join("g")
                        .attr("class", "arc-group");

      // Draw the arcs.
      groups.append("path")
            .attr("class", "arc")
            .attr("d", arc)
            .attr("fill", d => {
              if (d.depth === 1) return color(d.data.name);
              if (d.depth === 2) return color(d.parent.data.name);
              return "#ccc";
            })
            .on("mouseover", (event, d) => {
              tooltip.style("opacity", 1)
                     .html(`<strong>${d.data.name}</strong><br/>Jobs: ${d.value ? d.value.toLocaleString() : ''}`)
                     .style("left", (event.pageX + 10) + "px")
                     .style("top", (event.pageY + 10) + "px");
            })
            .on("mousemove", (event) => {
              tooltip.style("left", (event.pageX + 10) + "px")
                     .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", () => {
              tooltip.style("opacity", 0);
            });

      // Add labels.
      groups.append("text")
            .attr("class", "arc-label")
            .attr("dy", "0.35em")
            .attr("transform", d => {
              // Place the text at the arc's centroid.
              const c = arc.centroid(d);
              // Use our new computeTextRotation function.
              const rotation = computeTextRotation(d);
              return `translate(${c[0]},${c[1]}) rotate(${rotation})`;
            })
            .each(function(d) {
              if (d.depth === 0) return; // skip the root
              // Compute available width along the arc at mid-radius.
              const midRadius = (d.y0 + d.y1) / 2;
              const availableWidth = (d.x1 - d.x0) * midRadius;
              if (availableWidth < minLabelWidth) {
                d3.select(this).remove();
                return;
              }
              d3.select(this).text(d.data.name);
              wrap(d3.select(this), availableWidth);
            });
    }

    // Load CSV data and render the chart.
    function loadDataAndRender() {
      d3.csv("data.csv").then(rawData => {
        const parsed = rawData.map(d => ({
          generation: d["Generation"] || "Unknown",
          occupation: d["Occupation"] || "Unknown",
          jobs2013: +String(d["2013 Jobs"]).replace(/,/g, "")
        }));
        const hierarchyData = buildHierarchy(parsed);
        drawSunburst(hierarchyData);
      });
    }

    loadDataAndRender();
  </script>
</body>
</html>
