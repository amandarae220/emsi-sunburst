<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sunburst Chart â€“ Centered, Correctly Rotated Labels</title>
  <!-- Load d3.js v6 -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .arc {
      cursor: pointer;
      stroke: #fff;
      stroke-width: 1px;
    }
    .arc-label {
      fill: white;
      font-size: 12px;
      text-anchor: middle;
      pointer-events: none;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 6px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
    }
  </style>
</head>
<body>
  <svg id="sunburst" width="700" height="700"></svg>
  <div class="tooltip" id="tooltip"></div>
  <script>
    // Set up dimensions
    const width = 700,
          height = 700,
          radius = Math.min(width, height) / 2;
          
    // Select SVG and tooltip
    const svg = d3.select("#sunburst")
                  .attr("viewBox", [-width/2, -height/2, width, height]);
    const tooltip = d3.select("#tooltip");

    // Create a partition layout
    const partition = d3.partition()
                        .size([2 * Math.PI, radius]);

    // Create an arc generator
    const arc = d3.arc()
                  .startAngle(d => d.x0)
                  .endAngle(d => d.x1)
                  .innerRadius(d => d.y0)
                  .outerRadius(d => d.y1);

    // Color scale
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    // Define minimum available width for label (in pixels)
    const minLabelWidth = 12;

    // Revised computeTextRotation: Computes the mid-angle and then adjusts for readability.
    function computeTextRotation(d) {
      // Compute the midpoint angle in radians.
      let midAngle = (d.x0 + d.x1) / 2;
      let degrees = midAngle * 180 / Math.PI;
      // Flip text if the angle is between 90 and 270 degrees.
      return (degrees < 90 || degrees > 270) ? degrees : degrees + 180;
    }

    // Standard text wrapping function using <tspan>
    function wrap(text, width) {
      text.each(function() {
        var textElem = d3.select(this),
            words = textElem.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // in ems
            y = textElem.attr("y") || 0,
            dy = parseFloat(textElem.attr("dy")) || 0,
            tspan = textElem.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = textElem.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    // Build hierarchical data from CSV rows
    function buildHierarchy(csvData) {
      // Group data by generation then by occupation, summing 2013 Jobs
      const nestedMap = d3.rollup(
        csvData,
        v => d3.sum(v, d => d.jobs2013),
        d => d.generation,
        d => d.occupation
      );
      const root = { name: "All Jobs", children: [] };
      for (const [gen, occMap] of nestedMap.entries()) {
        const genNode = { name: gen, children: [] };
        for (const [occ, total] of occMap.entries()) {
          genNode.children.push({ name: occ, value: total });
        }
        root.children.push(genNode);
      }
      return root;
    }

    // Draw the sunburst chart with centered labels.
    function drawSunburst(data) {
      const root = d3.hierarchy(data)
                     .sum(d => d.value);
      partition(root);
      // Group for each node (arc and label)
      const groups = svg.selectAll("g.arc-group")
                        .data(root.descendants())
                        .join("g")
                        .attr("class", "arc-group");
      // Draw arcs
      groups.append("path")
            .attr("class", "arc")
            .attr("d", arc)
            .attr("fill", d => {
              if (d.depth === 1) return color(d.data.name);
              if (d.depth === 2) return color(d.parent.data.name);
              return "#ccc";
            })
            .on("mouseover", (event, d) => {
              tooltip.style("opacity", 1)
                     .html(`<strong>${d.data.name}</strong><br/>Jobs: ${d.value ? d.value.toLocaleString() : ''}`)
                     .style("left", (event.pageX + 10) + "px")
                     .style("top", (event.pageY + 10) + "px");
            })
            .on("mousemove", (event) => {
              tooltip.style("left", (event.pageX + 10) + "px")
                     .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", () => {
              tooltip.style("opacity", 0);
            });

      // Add labels: Position using arc.centroid and rotate using computeTextRotation.
      groups.append("text")
            .attr("class", "arc-label")
            .attr("dy", "0.35em")
            .attr("transform", d => {
              // Calculate centroid for placement.
              const c = arc.centroid(d);
              // Calculate the rotation angle for the label.
              const rotation = computeTextRotation(d);
              return `translate(${c[0]},${c[1]})rotate(${rotation})`;
            })
            .each(function(d) {
              if(d.depth === 0) return;  // Skip root
              // Compute available arc length at the midpoint radius.
              const midRadius = (d.y0 + d.y1) / 2;
              const availableWidth = (d.x1 - d.x0) * midRadius;
              if(availableWidth < minLabelWidth) {
                d3.select(this).remove();
                return;
              }
              // Set the label text and wrap if necessary.
              d3.select(this).text(d.data.name);
              wrap(d3.select(this), availableWidth);
            });
    }

    // Load CSV data and render the chart.
    function loadDataAndRender() {
      d3.csv("data.csv").then(rawData => {
        const parsed = rawData.map(d => ({
          generation: d["Generation"] || "Unknown",
          occupation: d["Occupation"] || "Unknown",
          jobs2013: +String(d["2013 Jobs"]).replace(/,/g, "")
        }));
        const hierarchyData = buildHierarchy(parsed);
        drawSunburst(hierarchyData);
      });
    }

    loadDataAndRender();
  </script>
</body>
</html>
