<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sunburst Chart – EMSI Data (Generation → Occupation) with Wrapped Labels</title>
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <!-- (Optional) Load the Tableau Extensions API -->
  <script src="https://tableau.github.io/extensions-api/tableau.extensions.1.latest.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .chart-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .arc {
      cursor: pointer;
      stroke: #fff;
      stroke-width: 1px;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 6px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
    }
    /* White text for labels */
    .arc-label {
      fill: white;
      font-size: 12px;
      text-anchor: middle;
      pointer-events: none; /* so text doesn't block mouse events on arcs */
    }
  </style>
</head>
<body>
  <h2>Sunburst Chart: Generation (Inner Ring) → Occupation (Outer Ring)</h2>
  <p>This visualization groups jobs by Generation and Occupation (using 2013 Jobs) with wrapped labels.</p>
  <div class="chart-container">
    <svg id="sunburst" width="700" height="700"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>

  <script>
    // -------------------------------------------------------------------
    // 1) Sunburst Layout Setup
    // -------------------------------------------------------------------
    const width = 700,
          height = 700,
          radius = Math.min(width, height) / 2;

    const svg = d3.select("#sunburst")
                  .attr("viewBox", [-width / 2, -height / 2, width, height]);

    const tooltip = d3.select("#tooltip");

    // Create a partition layout
    const partition = d3.partition()
      .size([2 * Math.PI, radius]);

    // Create an arc generator
    const arc = d3.arc()
      .startAngle(d => d.x0)
      .endAngle(d => d.x1)
      .innerRadius(d => d.y0)
      .outerRadius(d => d.y1);

    // Color scale (customize as needed)
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    // -------------------------------------------------------------------
    // 2) Build Hierarchy from CSV Data
    // -------------------------------------------------------------------
    function buildHierarchy(csvData) {
      // Group by Generation -> Occupation, summing "2013 Jobs"
      const nestedMap = d3.rollup(
        csvData,
        v => d3.sum(v, d => d.jobs2013),
        d => d.generation,
        d => d.occupation
      );

      const root = { name: "All Jobs", children: [] };
      for (const [genKey, occMap] of nestedMap.entries()) {
        const genNode = { name: genKey, children: [] };
        for (const [occKey, totalJobs] of occMap.entries()) {
          genNode.children.push({
            name: occKey,
            value: totalJobs
          });
        }
        root.children.push(genNode);
      }
      return root;
    }

    // -------------------------------------------------------------------
    // 3) Draw the Sunburst (with wrapped labels)
    // -------------------------------------------------------------------
    function drawSunburst(data) {
      const root = d3.hierarchy(data)
                     .sum(d => d.value);

      partition(root);

      // Group arcs and labels together
      const arcsGroup = svg.selectAll("g.arc-group")
        .data(root.descendants())
        .join("g")
        .attr("class", "arc-group");

      // Draw arcs
      arcsGroup.append("path")
        .attr("class", "arc")
        .attr("fill", d => {
          if (d.depth === 1) return color(d.data.name);
          if (d.depth === 2) return color(d.parent.data.name);
          return "#ccc";
        })
        .attr("d", arc)
        .on("mouseover", function(event, d) {
          tooltip.style("opacity", 1);
          const generation = (d.depth === 2) ? d.parent.data.name : d.data.name;
          const occupation = (d.depth === 2) ? d.data.name : "";
          const jobs = d.value ? d.value.toLocaleString() : "";
          tooltip.html(`
            <strong>${generation}</strong><br/>
            ${occupation ? occupation + "<br/>" : ""}
            Jobs: ${jobs}
          `)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY + 10) + "px");
        })
        .on("mousemove", function(event) {
          tooltip.style("left", (event.pageX + 10) + "px")
                 .style("top", (event.pageY + 10) + "px");
        })
        .on("mouseout", function() {
          tooltip.style("opacity", 0);
        })
        .on("click", function(event, d) {
          if (tableauEnv.isTableau) {
            applyTableauFilter(d);
          }
        });

      // Add labels with wrapping
      arcsGroup.append("text")
        .attr("class", "arc-label")
        .attr("transform", d => labelTransform(d))
        .attr("dy", "0.35em")
        .each(function(d) {
          // Skip the root and very small arcs
          if (d.depth === 0) return;
          const angle = d.x1 - d.x0;
          if (angle < 0.01) return;
          const labelText = d.data.name;
          // Compute available width along the arc
          const r = (d.y0 + d.y1) / 2;
          const availableWidth = angle * r - 4; // subtract a few pixels for padding
          const textElem = d3.select(this);
          textElem.text(labelText);
          wrap(textElem, availableWidth);
        });
    }

    // -------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------
    // Calculate label transform for positioning along the arc
    function labelTransform(d) {
      const angle = (d.x0 + d.x1) / 2;
      const rotate = (angle * 180 / Math.PI) - 90;
      const r = (d.y0 + d.y1) / 2;
      const flip = rotate < 180 ? 0 : 180;
      return `rotate(${rotate}) translate(${r},0) rotate(${flip})`;
    }

    // Wrap text for labels so that they don't overflow the arc.
    // This function creates tspans for each line if needed.
    function wrap(text, width) {
      text.each(function() {
        var textElem = d3.select(this),
            words = textElem.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = textElem.attr("y") || 0,
            dy = parseFloat(textElem.attr("dy")) || 0,
            tspan = textElem.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");

        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = textElem.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    // -------------------------------------------------------------------
    // 4) Load CSV and Render
    // -------------------------------------------------------------------
    function loadDataAndRender() {
      // Update this URL to match your GitHub Pages CSV location:
      d3.csv("data.csv").then(rawData => {
        const parsed = rawData.map(d => ({
          generation: d["Generation"] || "Unknown",
          occupation: d["Occupation"] || "Unknown",
          jobs2013: +String(d["2013 Jobs"]).replace(/,/g, "")
        }));

        const hierarchyData = buildHierarchy(parsed);
        drawSunburst(hierarchyData);
      });
    }

    // -------------------------------------------------------------------
    // 5) (Optional) Tableau Extensions – Two‐Way Filtering
    // -------------------------------------------------------------------
    const tableauEnv = {
      isTableau: false,
      worksheet: null
    };

    function applyTableauFilter(d) {
      const depth = d.depth;
      let filterField = null, filterValue = null;
      if (depth === 1) {
        filterField = "Generation";
        filterValue = d.data.name;
      } else if (depth === 2) {
        filterField = "Occupation";
        filterValue = d.data.name;
      } else return;
      if (tableauEnv.worksheet) {
        tableauEnv.worksheet.applyFilterAsync(filterField, filterValue, tableau.FilterUpdateType.Replace)
          .then(() => console.log(`Applied filter: ${filterField} = ${filterValue}`))
          .catch(err => console.error("Error applying filter:", err));
      }
    }

    function updateFromTableau(event) {
      console.log("Received Tableau filter event:", event);
      loadDataAndRender();
    }

    function setupTableauExtension() {
      if (typeof tableau === "undefined") {
        console.log("Not in a Tableau environment (test mode).");
        return;
      }
      tableau.extensions.initializeAsync().then(() => {
        tableauEnv.isTableau = true;
        const dashboard = tableau.extensions.dashboardContent.dashboard;
        tableauEnv.worksheet = dashboard.worksheets[0];
        dashboard.worksheets.forEach(ws => {
          ws.addEventListener(tableau.TableauEventType.FilterChanged, updateFromTableau);
        });
      });
    }

    // -------------------------------------------------------------------
    // 6) Initialize
    // -------------------------------------------------------------------
    loadDataAndRender();
    setupTableauExtension();
  </script>
</body>
</html>
